#
# Module with functions to compute VSTOXX sub-indexes
# data as generated by the script index_collect_option_data.py
# is needed for the calculations in this module
#
# (c) The Python Quants GmbH
# For illustration purposes only.
# December 2014
#
import numpy as np
import datetime as dt
import pandas as pd
import math
import index_date_functions as idf


def compute_subindex(data, delta_T, R):
    ''' Computes a sub-index for given option series data
    (of type pandas.DataFrame).

    data: pandas.DataFrame object
        contains the option data
    delta_T: float 
        time interval
    R: float
        discount factor
    '''

    data["Diff_Put_Call"] = np.abs(data.Put_Price - data.Call_Price)
      # difference between put and call option with same strike
    data = data.reset_index()
      # converts the strike price which serves as index so far
      # to a regular data column
    data["delta_K"] = None
    # differences between the different strikes of the series
    data["delta_K"][1:-1] = [(data["Strike price"][i + 1]
            - data["Strike price"][i - 1]) / 2 for i in data.index[1:-1]]
            # where possible, for the i-th entry it is
            # half of the difference between the (i-1)-th
            # and (i+1)-th price
    data["delta_K"][0] = data["Strike price"][1] - data["Strike price"][0]
      #  for i=0 it is just the difference to the next strike

    data.delta_K[data.index[-1:]] = float(data["Strike price"][-1:]) \
            - float(data["Strike price"][-2:-1])
            # for the last entry, it is just the difference
            # between the second but last strike and the last strike price

    min_Index = data.Diff_Put_Call.argmin()
    # find the smallest difference between put and call price

    forward_Price = data["Strike price"][min_Index] \
                    + R * data.Diff_Put_Call[min_Index]
                    # the forward price of that option

    K_0 = data["Strike price"][forward_Price -
                                    data["Strike price"] > 0].max()
    K_0_Index = data.index[data["Strike price"] == K_0][0]
      # the index of the ATM strike

    data["M"] = pd.concat((data.Put_Price[0:K_0_Index],
                           data.Call_Price[K_0_Index:]))
      # selects the OTM options

    data.M[K_0_Index] = (data.Call_Price[K_0_Index]
                            + data.Put_Price[K_0_Index]) / 2
      # ATM we take the average of put and call price

    data["MFactor"] = (R * (data.delta_K * data.M)
                         / (data["Strike price"]) ** 2)
      # the single OTM values

    fterm = 1. / delta_T * (forward_Price / K_0 - 1) ** 2 
      # the forward term
    
    sigma = 2 / delta_T * np.sum(data.MFactor) - fterm  # summing up
    
    subVSTOXX = 100 * math.sqrt(sigma)

    return subVSTOXX


def make_subindex(path):
    ''' Depending on the content of the file 'index_option_series.h5' ,
    the function computes the sub-indexes V6I1, V6I2 and parts
    of V6I3 and returns a pandas.DataFrame with the results.

    path: string
        string with path of data files
    '''

    datastore = pd.HDFStore(path + 'index_option_series.h5', 'r')
      # the data source, created with index_collect_option_data.py

    max_date = dt.datetime.today()  # find the latest date in the source
    for series in datastore.keys():
        dummy_date = datastore[series].index.get_level_values(0)[0]
        dummy_date = dummy_date.to_pydatetime()
        if dummy_date > max_date:
            max_date = dummy_date

    start_date = dt.datetime.today()  # find the earliest date in the source
    for series in datastore.keys():
        dummy_date = datastore[series].index.get_level_values(0)[0]
        dummy_data = dummy_date.to_pydatetime()
        if dummy_date < start_date:
            start_date = dummy_date

    V1 = dict()  # dicts to store the values, V stands for the sub-indices,
                 # T for their expiry
    V2 = dict()
    V3 = dict()
    T1 = dict()
    T2 = dict()
    T3 = dict()

    for day in pd.bdate_range(start=start_date.date(), end=max_date.date()):
      # from start_date to max_date, but only weekdays
        is_V1_defined = idf.not_a_day_before_expiry(day)
          # is V6I1 defined?
        settlement_date = idf.first_settlement_day(day)
          # the settlement date
        key = settlement_date.strftime("%b%y")
          # abbreviation for the expiry date, like Oct14
        delta_T = idf.compute_delta(day, settlement_date)
          # days until maturity
        try:
            data = datastore[key].ix[day]
              # data of the option series for that date
        except:
            continue

        if is_V1_defined:  # if V6I1 is defined
            V1[day] = compute_subindex(data, delta_T,
                                       math.exp(0.0015 * delta_T))
              # compute its value
            T1[day] = settlement_date
        else:
            V2[day] = compute_subindex(data, delta_T,
                                       math.exp(0.0015 * delta_T))
              # compute the value of V6I2 instead
            T2[day] = settlement_date

        settlement_date_2 = idf.second_settlement_day(day)

        # the same for the next index
        key_2 = settlement_date_2.strftime("%b%y")
        delta_T_2 = idf.compute_delta(day, settlement_date_2)
        data_2 = datastore[key_2].ix[day]

        if is_V1_defined:
            V2[day] = compute_subindex(data_2, delta_T_2,
                                       math.exp(0.001 * delta_T_2))
            T2[day] = settlement_date_2
        else:
            V3[day] = compute_subindex(data_2, delta_T_2,
                                       math.exp(0.001 * delta_T_2))
            T3[day] = settlement_date_2

    datastore.close()
    return pd.DataFrame(data={"V6I1": V1, "Expiry V6I1": T1, "V6I2": V2,
                    "Expiry V6I2": T2, "V6I3": V3, "Expiry V6I3": T3})
                    # create the pandas.DataFrame and return it


    
    
